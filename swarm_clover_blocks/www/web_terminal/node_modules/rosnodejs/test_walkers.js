const fs = require('fs');
const path = require('path');

async function* getPackages(directory) {
  const dir = await fs.promises.opendir(directory);

  let recurse = true;
  const subdirs = [];
  for await (const dirent of dir) {
    if (dirent.isDirectory()) {
      subdirs.push(dirent);
    }
    else if (dirent.isFile()) {
      if (dirent.name === 'CATKIN_IGNORE' || path.basename(dirent.name) === 'rospack_nosubdirs') {
        recurse = false;
      }
      else if (dirent.name === 'package.xml' || dirent.name === 'manifest.xml') {
        yield { packageName: path.basename(directory), directory };
        recurse = false;
      }
    }
  }

  if (recurse) {
    for (const dirent of subdirs) {
      // console.log('recurse into %s', dirent.name);
      yield* getPackages(path.join(directory, dirent.name));
    }
  }
}

async function* getMessages(directory, symlinks = []) {
  const dir = await fs.promises.opendir(directory);

  let recurse = true;
  const subdirs = [];
  for await (const dirent of dir) {
    if (dirent.isDirectory()) {
      subdirs.push(dirent);
    }
    else if (dirent.isFile()) {
      if (dirent.name === 'CATKIN_IGNORE' || path.basename(dirent.name) === 'rospack_nosubdirs') {
        recurse = false;
      }
      else {
        const extension = path.extname(dirent.name);
        const name = path.basename(dirent.name, extension);
        const file = path.join(directory, dirent.name);
        if (extension === '.msg') {
          yield { type: 'message', name, file };
        }
        else if (extension === '.srv') {
          yield { type: 'service', name, file };
        }
        else if (extension === '.action') {
          yield { type: 'action', name, file };
        }
      }
    }
    else if (dirent.isSymbolicLink()) {
      const linkPath = path.join(directory, dirent.name);
      const [targetPath, stats] = await Promise.all([
        fs.promises.readlink(linkPath),
        fs.promises.stat(linkPath)
      ]);
      if (symlinks.includes(targetPath)) {
        continue;
      }
      else if (stats.isDirectory()) {
        symlinks.push(targetPath);
        subdirs.push(dirent);
      }
    }
  }

  if (recurse) {
    for (const dirent of subdirs) {
      yield* getMessages(path.join(directory, dirent.name), symlinks);
    }
  }
}

async function main() {
  const p = path.resolve(__dirname, '..');
  console.log('Search [%s]', p);
  for await (const package of getPackages(p)) {
    console.log('Found package %s', package.packageName);
    for await (const message of getMessages(package.directory)) {
      console.log('Found %s %s at %s', message.type, message.name, message.file);
    }
  }
}

main();
